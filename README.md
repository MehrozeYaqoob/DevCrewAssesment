# DevCrewAssesment
This application is an assessment from DevCrew for recruiting purpose.

Theoretical Part is Answered Below:

What is the major difference between an abstract class and an interface?•	Abstract class can provide the implementation of interface whereas Interface can't provide the implementation of abstract class.•	Abstract class can have both abstract and non-abstract methods whereas Interface can have only abstract methods.•	Abstract class doesn't support multiple inheritance whereas Interface supports multiple inheritance.•	Abstract class can have final, non-final, static and non-static variables whereas Interface has only static and final variables.•	Abstract class can have static methods, main method and constructor whereas Interface can't have static methods, main method or constructor.•	The abstract keyword is used to declare abstract class whereas	the interface keyword is used to declare interface.Example Abstract Class:public abstract class Shape{public abstract void draw();}	Example Interface :public interface Drawable{void draw();}Why is Java 7’s class inheritance flawed?•	Static fields and methods should only be accessed through class name and not through a reference.Example:Abstract class Type1{	protected int value;}Interface Type2{	protected float value = 5.0;}public class MainType extends Type1 implements Type2{	public static void main(String[] args){	MainType t = new MainType();	t.value = 10; // This will compile in Java 8 but give error on Java 7}}What are the major differences between Activities and Fragments?•	Activity and Fragments differ in their lifecycle. An activity is placed into a back stack of activities that's managed by the system when it's stopped, However, a fragment is placed into a back stack managed by the host activity.•	An Activity is an application component that provides a screen, with which users can interact in order to do something, where as Fragments represents a behavior or portion of user interface.When using Fragments, how do you communicate back to their hosting Activity?To allow a Fragment to communicate up to its Activity, you can define an interface in the Fragment class and implement it within the Activity. The Fragment captures the interface implementation during its onAttach() lifecycle method and can then call the Interface methods in order to communicate with the Activity.Example: Via Developers.android.compublic class HeadlinesFragment extends ListFragment {    OnHeadlineSelectedListener mCallback;    // Container Activity must implement this interface    public interface OnHeadlineSelectedListener {        public void onArticleSelected(int position);    }    @Override    public void onAttach(Activity activity) {        super.onAttach(activity);                // This makes sure that the container activity has implemented        // the callback interface. If not, it throws an exception        try {            mCallback = (OnHeadlineSelectedListener) activity;        } catch (ClassCastException e) {            throw new ClassCastException(activity.toString()                    + " must implement OnHeadlineSelectedListener");        }    }        ...}Can you make an entire app without ever using Fragments? Why or why not? Are there any special cases when you absolutely have to use or should use Fragments?Yes, the entire app can be made without using fragments. It is true that Activities do render the UI for an application but Activities also have a lot of other responsibilities such as lifecycle management, platform interaction, etc. Putting this entire burden within the Activity class creates difficulties in dealing with device form factor differences. Ultimately one of two things happens.•	A single Activity has to provide a lot of special case handling for various form factors•	A separate Activity is created for each form factor with the non-UI details duplicated or otherwise shared across each ActivityFragments are necessary when it is useful only when the device is designed to present one pane or two panes view, according to its size. What makes an AsyncTask such an annoyance to Android developers? Detail some of the issues with AsyncTask, and how to potentially solve them?•	AsyncTask and Rotation: When the Activity is restarted, the AsyncTask’s reference to the Activity is invalid, so onPostExecute() will have no effect on the new Activity. Solution is to put the AsyncTask in a Fragment. (setRetainInstance(true)).•	Cancelling AsyncTasks: It’s up to the programmer to check whether the AsyncTask has been canceled so that you can halt your operation. Cancelling just marks the AsyncTask as cancel.•	Limitations on Concurrent AsyncTasks: When downloading bitmaps, if items are queued more than 138 tasks before they can complete, the app will crash. 
